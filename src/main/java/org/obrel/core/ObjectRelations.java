//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// This file is a part of the 'objectrelations' project.
// Copyright 2018 Elmar Sonnenschein, esoco GmbH, Flensburg, Germany
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
package org.obrel.core;

import de.esoco.lib.expression.Conversions;
import de.esoco.lib.expression.Predicate;
import de.esoco.lib.expression.Predicates;
import de.esoco.lib.json.JsonBuilder;
import de.esoco.lib.json.JsonParser;
import org.obrel.space.ObjectSpace;
import org.obrel.space.ObjectSpaceResolver;
import org.obrel.space.ObjectSpaceResolver.PutResolver;
import org.obrel.type.MetaTypes;
import org.obrel.type.StandardTypes;

import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.WeakHashMap;

import static de.esoco.lib.expression.Predicates.alwaysTrue;

/**
 * A class containing static methods for the handling of object relations. This
 * comprises especially the handling of relations for objects that are not
 * subclasses of {@link RelatedObject}. For this purpose this class contains
 * static variants of the methods in the {@link Relatable} interface, with an
 * additional object parameter that defines an arbitrary target object.
 *
 * @author eso
 */
public class ObjectRelations {

	private static final RelatedObject EMPTY_RELATION_CONTAINER =
		new RelatedObject();

	private static final Map<Object, RelatedObject> relationContainerMap =
		new WeakHashMap<Object, RelatedObject>();

	/**
	 * Private, only static use.
	 */
	private ObjectRelations() {
	}

	/**
	 * Copies all relations from a certain object to another object.
	 *
	 * @see #copyRelations(Relatable, Relatable, boolean, Predicate)
	 */
	public static void copyRelations(Relatable source, Relatable target,
		boolean replace) {
		copyRelations(source, target, replace, alwaysTrue());
	}

	/**
	 * Copies certain relations from a certain object to another object. The
	 * relations will be copied recursively so that the meta-relations on the
	 * source object's relations (also known as annotations) will be copied
	 * too.
	 * But the relation targets are only copied by reference. The invoking code
	 * is responsible to make sure that the duplication of target references
	 * won't cause problems.
	 *
	 * @param source  The source object to copy the relations from
	 * @param target  The target object to copy the relations to
	 * @param replace TRUE to replace existing relations in the target object,
	 *                FALSE to keep them
	 * @param filter  A predicate that filters the relations to copy
	 */
	public static void copyRelations(Relatable source, Relatable target,
		boolean replace, Predicate<Relation<?>> filter) {
		for (Relation<?> sourceRelation : source.getRelations(filter)) {
			sourceRelation.copyTo(target, replace);
		}
	}

	/**
	 * Parses a JSON string into the relations of a relatable object. The JSON
	 * string must be in a compatible format, e.g. like it is generated by
	 * {@link #toJson(Relatable, Collection)}.
	 *
	 * @param target The target for the parsed relations
	 * @param json   The JSON string to parse
	 * @return The target object
	 */
	public static <T extends Relatable> T fromJson(T target, String json) {
		return new JsonParser().parseRelatable(json, target);
	}

	/**
	 * Returns a relatable object for an arbitrary object that can be used to
	 * store relations for that object. The returned {@link Relatable} instance
	 * will be available as long as the original object has not been garbage
	 * collected, even if the calling code does not keep a reference to the
	 * returned object. If the argument is a relatable object already it
	 * will be
	 * returned unchanged.
	 *
	 * @param forObject The object to return a relatable object for
	 * @return A {@link Relatable} instance associated with the argument object
	 */
	public static Relatable getRelatable(Object forObject) {
		return getRelationContainer(forObject, true);
	}

	/**
	 * Internal method to determine the container that stores the relations
	 * of a
	 * particular object. If the given object is a related object it will
	 * simply
	 * be returned. Else, if create is TRUE a new relation container instance
	 * will be created and returned. And if create is FALSE an empty default
	 * container will be returned.
	 *
	 * @param object The object to return the data for
	 * @param create TRUE to create a new relation container, FALSE to
	 *                  return an
	 *               empty default
	 * @return The corresponding related object data instance
	 */
	static RelatedObject getRelationContainer(Object object, boolean create) {
		if (object instanceof RelatedObject) {
			return (RelatedObject) object;
		} else {
			synchronized (relationContainerMap) {
				RelatedObject container = relationContainerMap.get(object);

				if (container == null) {
					if (create) {
						container = new RelatedObject();
						relationContainerMap.put(object, container);
					} else {
						container = EMPTY_RELATION_CONTAINER;
					}
				}

				return container;
			}
		}
	}

	/**
	 * Globally initializes the object relations framework. This method should
	 * be invoked as early as possible by applications that use object
	 * relations. At the moment it only registers the standard relation types
	 * that are defined in the classes of the package {@code org.obrel.type} by
	 * means of the method {@link #registerRelationTypes(Class...)}. But future
	 * versions may perform additional tasks and therefore it is recommended to
	 * always invoke it.
	 */
	public static void init() {
		registerRelationTypes(RelationTypes.class, MetaTypes.class,
			StandardTypes.class);
	}

	/**
	 * Registers all relation types that are defined in the given classes.
	 * Normally a relation type is registered automatically when it is used for
	 * the first time but there are possible situations where that may not have
	 * happened yet. A typical case is the deserialization of a related object
	 * which contains relations of a type class that hasn't been loaded at the
	 * time of deserialization.
	 *
	 * <p>For this reason applications should always register the relation
	 * types they use for all classes that contain application-defined relation
	 * types. This can be done either at initialization time (i.e. on
	 * application start) or (if possible) on demand when a type is accessed
	 * for
	 * the first time (e.g. by using a special relation type superclass with a
	 * static initializer that invokes this method).</p>
	 *
	 * <p>Because this method may be extended in the future to provide support
	 * for enhanced features (like distributed object spaces or remote
	 * relations) applications should always register relation types by
	 * invoking
	 * this method instead of simply loading the class that defines the types.
	 * </p>
	 *
	 * @param typees A list of classes to register all defined types of
	 */
	public static void registerRelationTypes(Class<?>... typees) {
		assert typees.length > 0 : "No classes to register";

		for (Class<?> type : typees) {
			try {
				// only accessing the class may not be sufficient because
				// ineffective code could be removed by compiler optimizations
				Class.forName(type.getName());
			} catch (ClassNotFoundException e) {
				// this should not be possible
				throw new IllegalStateException(e);
			}
		}
	}

	/**
	 * Removes the relatable object that has been associated previously with a
	 * certain object. If no relatable object exists calling this method will
	 * have no effect.
	 *
	 * @param forObject The object to remove the relatable object for
	 */
	public static void removeRelatable(Object forObject) {
		relationContainerMap.remove(forObject);
	}

	/**
	 * Validates that certain relations exist on a target object or else throws
	 * an {@link IllegalArgumentException}.
	 *
	 * @see #require(Relatable, Predicate, RelationType...)
	 */
	public static void require(Relatable relatable, RelationType<?>... types) {
		require(relatable, Predicates.alwaysTrue(), types);
	}

	/**
	 * Validates that certain relations exist on a target object and fulfill
	 * certain requirements or else throws an {@link IllegalArgumentException}.
	 * Non-existing relations with one of the given types will cause an
	 * immediate exception. All others will be tested with the argument
	 * predicate of which a return value of FALSE will also yield an exception.
	 *
	 * @param relatable   The relatable to validate
	 * @param requirement A predicate that tests whether a relation fulfills
	 *                      the
	 *                    requirements
	 * @param types       The relation types that must be set on the object
	 *                       with
	 *                    any kind of value, including NULL
	 * @throws IllegalArgumentException If one or more relations don't exist or
	 *                                  the requirement predicate yields FALSE
	 */
	public static void require(Relatable relatable,
		Predicate<Relation<?>> requirement, RelationType<?>... types) {
		Set<RelationType<?>> missingTypes = new LinkedHashSet<>();

		for (RelationType<?> type : types) {
			Relation<?> relation = relatable.getRelation(type);

			if (relation == null || !requirement.test(relation)) {
				missingTypes.add(type);
			}
		}

		if (!missingTypes.isEmpty()) {
			throw new IllegalArgumentException(
				"Relations missing: " + missingTypes);
		}
	}

	/**
	 * Validates that certain relations exist on a target object with a
	 * non-null
	 * value or else throws an {@link IllegalArgumentException}.
	 *
	 * @see #require(Relatable, Predicate, RelationType...)
	 */
	@SuppressWarnings("boxing")
	public static void requireNonNull(Relatable relatable,
		RelationType<?>... types) {
		require(relatable, r -> r.getTarget() != null, types);
	}

	/**
	 * A helper method to set a certain relation on multiple objects.
	 *
	 * @param type    The type of the relation to set
	 * @param target  The relation target value
	 * @param objects The objects to set the relation on
	 */
	public static <T> void setAll(RelationType<T> type, T target,
		Relatable... objects) {
		for (Relatable object : objects) {
			object.set(type, target);
		}
	}

	/**
	 * A helper method to set a certain boolean relation to TRUE on multiple
	 * objects.
	 *
	 * @param flagType The boolean type of the relation
	 * @param objects  The objects to set the flag on
	 */
	public static void setFlags(RelationType<Boolean> flagType,
		Relatable... objects) {
		setAll(flagType, Boolean.TRUE, objects);
	}

	/**
	 * Performs a shutdown by freeing global resources.
	 */
	public static void shutdown() {
		relationContainerMap.clear();
	}

	/**
	 * Swaps the relations of two objects. All relations will be exchanged
	 * directly between the two objects, making the first object contain only
	 * the relations of the second and vice versa.
	 *
	 * @param first  The first object to swap the relations of the second to
	 * @param second The second object to swap the relations of the first to
	 */
	public static void swapRelations(RelatedObject first,
		RelatedObject second) {
		Map<RelationType<?>, Relation<?>> secondRelations = second.relations;

		second.relations = first.relations;
		first.relations = secondRelations;
	}

	/**
	 * Synchronizes the relations of a target object with that of a source
	 * object. All previous relations of the target object will be deleted and
	 * instead both objects will refer to the same relations and changes to the
	 * relations will be visible in both objects.
	 *
	 * @param target The target object to replace the relations of
	 * @param source The object replace the target object's relations with
	 */
	public static void syncRelations(RelatedObject target,
		RelatedObject source) {
		target.relations = source.relations;
	}

	/**
	 * Converts a relatable object into a JSON string from the object's
	 * relations. If no relation types are provided all relations of the object
	 * will be converted to JSON. In that case it is important that there
	 * are no
	 * cycles in the relations (i.e. objects referring each other) or else an
	 * endless loop will occur. Furthermore all relations in the source object
	 * must be convertible to strings, i.e. should either have a basic (JSON)
	 * datatype or a conversion to string registered with
	 * {@link Conversions#registerStringConversion(Class,
	 * de.esoco.lib.expression.InvertibleFunction)}. If not the resulting JSON
	 * string will probably not be parseable by the method
	 * {@link #fromJson(Relatable, String)}.
	 *
	 * @param object        The object to convert
	 * @param relationTypes The types of the relation to be converted to JSON
	 *                      (none for all)
	 * @return The resulting JSON string
	 */
	public static String toJson(Relatable object,
		RelationType<?>... relationTypes) {
		List<RelationType<?>> types =
			relationTypes.length > 0 ? Arrays.asList(relationTypes) : null;

		return toJson(object, types);
	}

	/**
	 * Converts a certain relations of a relatable object into a JSON string
	 * from the object's relations. References to other related objects are
	 * converted recursively.
	 *
	 * @param object        The object to convert
	 * @param relationTypes The types of the relation to be converted to JSON
	 * @return The resulting JSON string
	 */
	public static String toJson(Relatable object,
		Collection<RelationType<?>> relationTypes) {
		return new JsonBuilder()
			.appendRelatable(object, relationTypes, true)
			.toString();
	}

	/**
	 * Deletes a relation referenced by a URL. The URL will be split into
	 * relation type names that are looked up recursively from the relation
	 * hierarchy starting at the given root object. That means all intermediate
	 * elements of the URL must refer to {@link Relatable} instances. If the
	 * hierarchy doesn't match the URL an exception will be thrown.
	 *
	 * @param root The root relatable to start the URL lookup at
	 * @param url  The URL of the relation to get the value from
	 * @throws NoSuchElementException   If the URL could not be resolved
	 * @throws IllegalArgumentException If the URL doesn't resolve to a valid
	 *                                  relation type
	 */
	public static void urlDelete(Relatable root, String url) {
		urlResolve(root, url, true, ObjectSpaceResolver.URL_DELETE);
	}

	/**
	 * Returns a relation value referenced by a URL. The URL will be split into
	 * relation type names that are looked up recursively from the relation
	 * hierarchy starting at the given root object. That means all intermediate
	 * elements of the URL must refer to {@link Relatable} instances. If the
	 * hierarchy doesn't match the URL an exception will be thrown.
	 *
	 * @param root The root relatable to start the URL lookup at
	 * @param url  The URL of the relation to get the value from
	 * @return The value at the given URL
	 * @throws NoSuchElementException   If the URL could not be resolved
	 * @throws IllegalArgumentException If the URL doesn't resolve to a valid
	 *                                  relation type
	 */
	public static Object urlGet(Relatable root, String url) {
		return urlResolve(root, url, true, ObjectSpaceResolver.URL_GET);
	}

	/**
	 * Internal helper method to throw a {@link NoSuchElementException} upon a
	 * URL resolving error.
	 *
	 * @param url     The URL to resolve
	 * @param element The URL element that could not be resolved
	 */
	private static void urlLookupError(String url, String element) {
		String message =
			String.format("Could not resolve element '%s' in URL '%s'",
				element,
				url);

		throw new NoSuchElementException(message);
	}

	/**
	 * Sets or updates a relation value referenced by a URL. The URL will be
	 * split into relation type names that are looked up recursively from the
	 * relation hierarchy starting at the given root object. That means all
	 * intermediate elements of the URL must refer to {@link Relatable}
	 * instances. If the hierarchy doesn't match the URL an exception will be
	 * thrown.
	 *
	 * @param root  The root relatable to start the URL lookup at
	 * @param url   The URL of the relation to update
	 * @param value The new or updated value
	 * @throws NoSuchElementException   If the URL could not be resolved
	 * @throws IllegalArgumentException If the URL doesn't resolve to a valid
	 *                                  relation type or if the given value
	 *                                  cannot be assigned to the relation type
	 */
	public static void urlPut(Relatable root, String url, Object value) {
		urlResolve(root, url, true, new PutResolver<Object>(value));
	}

	/**
	 * Performs a lookup of a relation through a URL by splitting it into
	 * relation type names and if possible recursively applying them to the
	 * hierarchy of relatable objects referenced by the relations types. If the
	 * URL could be successfully resolved the target handler will be invoked.
	 * This must be a binary function that receives the target relatable and
	 * relation type (representing the second-to-last and last URL elements)
	 * and
	 * return either a result value or NULL if the arguments are just consumed.
	 *
	 * @param root                 The root relatable for the lookup
	 * @param url                  The URL to resolve
	 * @param forwardToObjectSpace TRUE if the resolving should be forwarded to
	 *                             an object space on the first level
	 *                             instead of
	 *                             resolving a relation
	 * @param targetHandler        The target handler function
	 * @return The result of the function evaluation
	 * @throws NoSuchElementException   If some element of the URL could not be
	 *                                  resolved
	 * @throws IllegalArgumentException If the URL doesn't resolve to a valid
	 *                                  relation type
	 */
	public static Object urlResolve(Relatable root, String url,
		boolean forwardToObjectSpace, ObjectSpaceResolver targetHandler) {
		String[] elements = url.split("/");
		Object nextElement = root;
		Relatable currentElement = root;
		RelationType<?> type = null;
		int childUrlIndex = 0;

		for (String element : elements) {
			// ignore empty URL elements (// or / at start or end)
			if (!element.isEmpty()) {
				element = element.replaceAll("-", "_");

				if (forwardToObjectSpace &&
					nextElement instanceof ObjectSpace) {
					// let child-spaces perform the lookup by themselves
					return targetHandler.resolve((ObjectSpace<?>) nextElement,
						url.substring(childUrlIndex));
				} else if (nextElement instanceof Relatable) {
					currentElement = (Relatable) nextElement;
				} else {
					urlLookupError(url, element);
				}

				int packageEnd = element.lastIndexOf('.') + 1;

				if (packageEnd > 0) {
					element = element.substring(0, packageEnd) +
						element.substring(packageEnd).toUpperCase();
				} else {
					element = element.toUpperCase();
				}

				type = RelationType.valueOf(element);

				if (type != null) {
					nextElement = currentElement.get(type);
				} else {
					String elem = element;

					Relation<?> elementRelation = currentElement
						.streamRelations()
						.filter(r -> r.getType().getName().endsWith(elem))
						.findFirst()
						.orElse(null);

					if (elementRelation != null) {
						nextElement = elementRelation.getTarget();
						type = elementRelation.getType();
					} else {
						urlLookupError(url, element);
					}
				}
			}

			// position after element and trailing '/'
			childUrlIndex += element.length() + 1;

			// only skip forwarding for the first level
			forwardToObjectSpace = true;
		}

		if (type == null) {
			throw new IllegalArgumentException("Could not resolve URL " + url);
		}

		return targetHandler.evaluate(currentElement, type);
	}
}
